Module rdee_base
    Implicit none

Contains
    Subroutine assert(bval, msg)
        Implicit none
        Logical, Intent(in) :: bval
        Character(*), Intent(in) :: msg
        
        If (.not. bval) then
            write(*,*) msg
            Stop 999
        Endif

    End Subroutine assert

    elemental integer function eq_um(x, y) result(rst)
        implicit none
        ! ··················· Arguments
        class(*), intent(in) :: x, y

        select type(xp => x)
            !#jj2 for type in ['integer(kind=4)', 'integer(kind=8)', 'real(kind=4)', 'real(kind=8)', 'logical', 'character(*)']:
            !#jj2 set eq_sym = '.eqv.' if type.startswith('logical') else '.eq.'
            type is ({{ type }})
                select type(yp => y)
                    type is ({{ type }})
                        rst = 0
                        if (xp {{ eq_sym }} yp) rst = 1
                    class default
                        rst = -1
                end select
            !#jj2 endfor
            class default
                rst = -2
        end select
        return
    end function

    
    integer function eq_1d_um(x, y) result(rst)
        implicit none
        ! ··················· Arguments
        class(*), intent(in) :: x(:), y(:)

        select type(xp => x)
            !#jj2 for type in ['integer(kind=4)', 'integer(kind=8)', 'real(kind=4)', 'real(kind=8)', 'logical', 'character(*)']:
            !#jj2 set eq_sym = '.eqv.' if type.startswith('logical') else '.eq.'
            type is ({{ type }})
                select type(yp => y)
                    type is ({{ type }})
                        rst = 0
                        if (all(xp {{ eq_sym }} yp)) rst = 1
                    class default
                        rst = -1
                end select
            !#jj2 endfor
            class default
                rst = -2
        end select
        return
    end function

    !#jj2 for opn in ['add', 'sub', 'mul', 'div']
    !#jj2 set op = '+' if opn == 'add' else '-' if opn == 'sub' else '*' if opn == 'mul' else '/'
    !#jj2 set vn = type[0] + type[-1]
    function add_um(um1, um2) result(rst)
        implicit none
        ! ··················· Arguments
        class(*), intent(in) :: um1, um2
        class(*),allocatable :: rst
        ! ··················· main body
        Select type(up1 => um1)
            !#jj2 for type in ['int4', 'int8', 'real4', 'real8']:
            type is ({{ ftype[type] }})
                select type(up2 => um2)
                    !#jj2 for type2 in ['int4', 'int8', 'real4', 'real8']:
                    type is ({{ ftype[type2] }})
                        rst = up1 {{ op }} up2
                    !#jj2 endfor
                    class default
                        print *, 'Error! unmatched data types for um1 and um2'
                        stop 1
                end select
            !#jj2 endfor
            class default
                print *, 'the class(*) u is not {{ ftype[type] }}'
                stop 1
        end select
    end function
    !#jj2 endfor

End Module
