Module rdee_string
    ! use rdee_ds
    use rdee_array
    implicit none

Contains


! *********************************************************
! Series apis for String classifictions
! *********************************************************
Logical Function isNumeric(S) result(rst)
    implicit none
    character(len=*), intent(in) :: S
    integer(kind=4) :: ierr
    real(kind=4) :: r

    read(S, *, iostat=ierr) r
    rst = .true.
    if (ierr .ne. 0) rst = .false.
End Function isNumeric


! *********************************************************
! Series apis for String extractions
! *********************************************************
Function S8idx(S, idx) result(rst)  ! String by index
    !!! Slice a Character by indexes
    implicit none
    character(len=*), intent(in) :: S
    integer(kind=4) :: idx(:)

    character(len=size(idx)) :: rst

    integer(kind=4) :: i
    
    ! ................................. main body
    do i = 1, size(idx)
        rst(i:i) = S(idx(i):idx(i))
    end do
End Function S8idx

Function S3digits(S) result(rst)  ! String extract (3) digits
    !!! extract only digits from given string <arg:S>
    implicit none
    character(len=*), intent(in) :: S

    integer(kind=4), allocatable :: aidxs(:)  ! ascii indexes
    integer(kind=4), allocatable :: didxs(:)  ! digit indexes
    character(len=:), allocatable :: rst

    aidxs = ichar(s2ca(S))
    didxs = ind(aidxs .ge. 48 .and. aidxs .le. 57)
    rst = S8idx(S, didxs)
    deallocate(aidxs)
    deallocate(didxs)
End Function S3digits


Function s2ca(S) result(rst)
    implicit none
    character(len=*), intent(in) :: S
    character(len=1) :: rst(len_trim(S))

    integer(kind=4) :: i
    do i = 1, len_trim(S)
        rst(i) = S(i:i)
    end do

End Function

Function ca2s(ca) result(rst)
    implicit none
    character(len=1), intent(in) :: ca(:)
    character(len=size(ca)):: rst

    integer(kind=4) :: i
    do i = 1, size(ca)
        rst(i:i) = ca(i)
    end do

End Function


! *********************************************************
! This subroutine aims to get indexes for specific char in string
! *********************************************************
! this version is deprecated due to avoiding circular use
! subroutine argwhere_c1s(S, c, idxs)  ! char in(1 as homophonic) string
!     implicit none
!     ! ......................... Arguments
!     character(len=*), intent(in) :: S
!     character, intent(in) :: c
!     integer(kind=4), allocatable, intent(out) :: idxs(:)
!     ! ......................... Local variables
!     type(list) :: rst_list
!     integer :: i

!     ! ......................... main body
!     rst_list = list()
!     do i = 1, len_trim(S)
!         if (S(i:i) .eq. c) then
!             call rst_list%append(i)
!         end if
!     end do

!     call rst_list%toArray(idxs)

!     return

! end subroutine argwhere_c1s

subroutine argwhere_c1s(S, c, idxs)  ! char in(1 as homophonic) string
    implicit none
    ! ......................... Arguments
    character(len=*), intent(in) :: S
    character, intent(in) :: c
    integer(kind=4), allocatable, intent(out) :: idxs(:)
    ! ......................... Local variables
    integer(kind=4) :: iBuffer(len_trim(S))
    integer :: i, j

    ! ......................... main body
    j = 1
    do i = 1, len_trim(S)
        if (S(i:i) .eq. c) then
            iBuffer(j) = i
            j = j + 1   
        end if
    end do

    idxs = iBuffer(1:j)    

    return
end subroutine argwhere_c1s

! *********************************************************
! This subroutine aims to convert all generic data type into string
! based on "https://fortranwiki.org/fortran/show/tostring"
! add argumernt: nSpace
! *********************************************************
function toString(generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, nSpace)
implicit none

! convert up to nine scalar intrinsic values to a string

class(*),intent(in),optional  :: generic1 ,generic2 ,generic3 ,generic4, generic5
class(*),intent(in),optional  :: generic6 ,generic7 ,generic8 ,generic9
integer, intent(in), optional :: nSpace
integer :: nSpace_
character(len=:), allocatable :: tostring
character(len=300)        :: line
integer                    :: istart

if (present(nSpace)) then
  nSpace_ = nSpace
else
  nSpace_ = 0
end if

   istart=1
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   tostring=trim(line)
contains
    subroutine print_generic(generic)
        use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
        class(*),intent(in),optional :: generic

        select type(generic)
            type is (integer(kind=int8));     write(line(istart:),'(i0)') generic
            type is (integer(kind=int16));    write(line(istart:),'(i0)') generic
            type is (integer(kind=int32));    write(line(istart:),'(i0)') generic
            type is (integer(kind=int64));    write(line(istart:),'(i0)') generic
            type is (real(kind=real32));      write(line(istart:),'(1pg0)') generic
            type is (real(kind=real64));      write(line(istart:),'(1pg0)') generic
            type is (real(kind=real128));     write(line(istart:),'(1pg0)') generic
            type is (logical);                write(line(istart:),'(a)') generic
            type is (character(len=*));       write(line(istart:),'(a)') generic
            type is (complex);                write(line(istart:),'("(",1pg0,",",1pg0,")")') generic
        end select
        istart=len_trim(line)+1+nSpace_
    end subroutine print_generic
end function tostring



! *********************************************************
! This function aims to build a string array from strings
! with different length
! *********************************************************
function string1dBuilder(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10) result(rst)
    implicit none
    ! ................................. Arguments
    character(*), intent(in) :: s1, s2
    character(*), intent(in), optional :: s3, s4, s5, s6, s7, s8, s9, s10
    ! ................................. Return variable
    character(len=:), allocatable :: rst(:)
    ! ................................. Local variable
    integer :: maxL, size
    integer :: j
    ! ................................. Main body
    maxL = max(len_trim(s1), len_trim(s2))
    size = 2
    !#jj2 for i in [3,4,5,6,7,8,9,10]:
    if (present(s{{ i }})) then
        maxL = max(maxL, len_trim(s{{ i }}))
        size = size + 1
    end if
    !#jj2 endfor
    allocate(character(len=maxL) :: rst(size))

    rst(1) = s1
    rst(2) = s2
    
    j = 3
    !#jj2 for i in [3,4,5,6,7,8,9,10]:
    if (present(s{{ i }})) then
        rst(j) = s{{ i }}
        j = j + 1
    end if
    !#jj2 endfor 

    return
end function



! *********************************************************
! Series of functions for type converting between string
! and numerical variables 
! *********************************************************
Function s2i4(s)
    implicit none
    Character(len=*), intent(in) :: s
    integer(kind=4) :: s2i4

    read(s,*) s2i4
End Function s2i4

Function s2i8(s)
    implicit none
    Character(len=*), intent(in) :: s
    integer(kind=8) :: s2i8

    read(s,*) s2i8
End Function s2i8

Function s2r4(s)
    implicit none
    Character(len=*), intent(in) :: s
    real(kind=4) :: s2r4

    read(s,*) s2r4
End Function s2r4

Function s2r8(s)
    implicit none
    Character(len=*), intent(in) :: s
    real(kind=8) :: s2r8

    read(s,*) s2r8
End Function s2r8

Function i42s(ir) result(rst)
    implicit none
    integer(kind=4), intent(in) :: ir
    Character(len=:), allocatable :: rst
    Character(len=30) :: rst_

    write(rst_,'(I0)') ir
    rst = trim(rst_)
End Function i42s

Function i82s(ir) result(rst)
    implicit none
    integer(kind=8), intent(in) :: ir
    Character(len=:), allocatable :: rst
    Character(len=30) :: rst_

    write(rst_,'(I0)') ir
    rst = trim(rst_)
End Function i82s

Function r42s(ir, decimal) result(rst)
    implicit none
    real(kind=4), intent(in) :: ir
    integer(kind=4), intent(in), optional :: decimal

    Character(len=:), allocatable :: rst
    Character(len=30) :: rst_

    if (present(decimal)) then
        write(rst_, toString('(F0.', decimal, ')')) ir
    else
        write(rst_, '(1pg0)') ir
    end if
    rst = trim(rst_)
End Function r42s

Function r82s(ir, decimal) result(rst)
    implicit none
    real(kind=8), intent(in) :: ir
    integer(kind=4), intent(in), optional :: decimal

    Character(len=:), allocatable :: rst
    Character(len=30) :: rst_

    
    if (present(decimal)) then
        write(rst_, toString('(F0.', decimal, ')')) ir
    else
        write(rst_, '(1pg0)') ir
    end if
    rst = trim(rst_)
End Function r82s

 

! *********************************************************
! trim a string in both sides, and relative apis
! *********************************************************
Function trim2(S)
    implicit none
    character(len=*), intent(in) :: S
    character(len=:), allocatable :: trim2

    integer(kind=4) :: i, L

    L = len_trim(S)
    if (L .eq. 0) then
        trim2 = ''
    else
        do i = 1, len_trim(S)
            if (S(i:i) .ne. ' ') exit
        end do
        trim2 = trim(S(i:))
    end if

End Function

Function len_trim2(S)
    implicit none
    character(len=*), intent(in) :: S
    integer(kind=4) :: len_trim2

    len_trim2 = len(trim2(S))

End Function

End Module
